const { test, expect } = require('@playwright/test');

/**
 * Real Print Test - Matches actual browser print behavior
 * Tests against how browsers actually handle print media queries
 */

test.describe('Real Print Behavior Tests', () => {
  test('Real browser print preview matches content visibility', async ({
    page,
  }) => {
    const filePath = `file://${process.cwd()}/dist/index.html`;
    await page.goto(filePath);
    await page.waitForLoadState('networkidle');

    // Use real browser print media emulation
    await page.emulateMedia({ media: 'print' });
    await page.waitForTimeout(1000); // Allow all CSS transitions

    // Take screenshot of what would actually print
    const printScreenshot = await page.screenshot({
      fullPage: true,
      path: 'test-results/real-print-preview.png',
    });

    // Critical tests for real print behavior

    // 1. Header should be visible but not take up whole page
    const header = page.locator('.header');
    await expect(header).toBeVisible();
    const headerBox = await header.boundingBox();
    expect(headerBox.height).toBeLessThan(300); // Should not take up whole page

    // 2. Main content must be visible
    const mainContent = page.locator('.main-content');
    await expect(mainContent).toBeVisible();

    // 3. At least one work experience item must be visible
    const workItems = page.locator('.work-item');
    const workCount = await workItems.count();
    if (workCount > 0) {
      await expect(workItems.first()).toBeVisible();

      // Check that work item actually has content
      const workText = await workItems.first().textContent();
      expect(workText.trim().length).toBeGreaterThan(10);
    }

    // 4. At least one section must be visible
    const sections = page.locator('.section');
    const sectionCount = await sections.count();
    expect(sectionCount).toBeGreaterThan(0);

    for (let i = 0; i < Math.min(sectionCount, 3); i++) {
      await expect(sections.nth(i)).toBeVisible();
    }

    // 5. Check that page has reasonable height (content is showing)
    const bodyBox = await page.locator('body').boundingBox();
    expect(bodyBox.height).toBeGreaterThan(800); // Should have substantial content

    // 6. Header should not have gradient background in print
    const headerBg = await header.evaluate(
      el => window.getComputedStyle(el).backgroundImage
    );
    expect(headerBg).toBe('none'); // Should not have gradient

    // 7. Text should be black for print
    const headerColor = await header.evaluate(
      el => window.getComputedStyle(el).color
    );
    expect(headerColor).toBe('rgb(0, 0, 0)'); // Should be black

    console.log(
      '✅ Real print test completed - screenshot saved to test-results/real-print-preview.png'
    );
  });

  test('Puppeteer PDF generation matches print preview', async ({ page }) => {
    // This test verifies that the PDF generated by build.js matches what we see in browser
    const filePath = `file://${process.cwd()}/dist/index.html`;
    await page.goto(filePath);
    await page.waitForLoadState('networkidle');

    // Generate PDF the same way build.js does
    await page.emulateMedia({ media: 'print' });
    await page.waitForTimeout(1000);

    const pdfBuffer = await page.pdf({
      format: 'A4',
      printBackground: true,
      preferCSSPageSize: true,
      displayHeaderFooter: false,
      margin: { top: '0', bottom: '0', left: '0', right: '0' },
      scale: 0.95,
      tagged: true,
      title: 'Rafael Bernardo Sathler - Resume',
      author: 'Rafael Bernardo Sathler',
      subject:
        'Infrastructure Engineer Resume - Platform Engineering and DevOps Portfolio',
      keywords:
        'Infrastructure Engineer, DevOps, Platform Engineer, AWS, GCP, Kubernetes, CI/CD, Cloud Architect',
      creator: 'Resume-as-Code System',
      producer: 'Puppeteer PDF Generator',
    });

    // PDF should have content (not empty)
    expect(pdfBuffer.length).toBeGreaterThan(50000); // Reasonable size for resume with content

    console.log(`✅ PDF generated: ${pdfBuffer.length} bytes`);
  });

  test('Compare screen vs print media differences', async ({ page }) => {
    const filePath = `file://${process.cwd()}/dist/index.html`;
    await page.goto(filePath);
    await page.waitForLoadState('networkidle');

    // Take screenshot in screen mode
    await page.emulateMedia({ media: 'screen' });
    await page.waitForTimeout(500);

    const screenShot = await page.screenshot({
      fullPage: true,
      path: 'test-results/screen-mode.png',
    });

    // Check elements visible in screen mode
    const darkToggle = page.locator('.dark-toggle');
    const socialLinks = page.locator('.links');

    if ((await darkToggle.count()) > 0) {
      await expect(darkToggle).toBeVisible();
    }
    if ((await socialLinks.count()) > 0) {
      await expect(socialLinks).toBeVisible();
    }

    // Switch to print mode
    await page.emulateMedia({ media: 'print' });
    await page.waitForTimeout(1000);

    const printShot = await page.screenshot({
      fullPage: true,
      path: 'test-results/print-mode.png',
    });

    // Check elements hidden in print mode
    if ((await darkToggle.count()) > 0) {
      await expect(darkToggle).toBeHidden();
    }
    if ((await socialLinks.count()) > 0) {
      await expect(socialLinks).toBeHidden();
    }

    // Content should still be visible
    const mainContent = page.locator('.main-content');
    await expect(mainContent).toBeVisible();

    console.log('✅ Screen vs Print comparison completed');
  });
});
