# ğŸ¤– Intelligent PR Automation Bot
# Advanced PR management with conventional commits and BRT timezone optimization
# Handles auto-merge, labeling, review requests, and maintenance tasks

name: ğŸš€ PR Automation Bot

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  pull_request_target:
    types: [opened, synchronize, reopened]
  issue_comment:
    types: [created]
  schedule:
    # PR maintenance every weekday at 8 AM BRT (11:00 UTC-3)
    - cron: '0 11 * * 1-5'
  workflow_dispatch:
    inputs:
      automation_type:
        description: 'Type of PR automation to run'
        required: true
        default: 'maintenance'
        type: choice
        options:
          - maintenance
          - label-all-prs
          - cleanup-stale
          - auto-merge-ready
          - test-commands
      pr_number:
        description: 'Specific PR number to target (optional)'
        required: false
        type: string
      dry_run:
        description: 'Dry run mode (no actual changes)'
        required: false
        default: false
        type: boolean

concurrency:
  group: pr-automation-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: false  # Don't cancel PR automation

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read
  actions: read

env:
  NODE_OPTIONS: '--no-deprecation --no-warnings'

jobs:
  # ğŸ·ï¸ Intelligent PR Labeling & Classification
  pr-labeling:
    name: ğŸ·ï¸ Smart PR Labeling
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'pull_request_target'
    continue-on-error: true  # Non-blocking
    
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Analyze PR and apply labels
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;
            const prTitle = context.payload.pull_request.title.toLowerCase();
            const prBody = context.payload.pull_request.body || '';
            const files = await github.rest.pulls.listFiles({ owner, repo, pull_number: prNumber });
            
            const labels = [];
            
            // ğŸ¯ Conventional commit type detection
            if (prTitle.includes('feat:') || prTitle.includes('feature:')) {
              labels.push('enhancement', 'feature');
            }
            if (prTitle.includes('fix:') || prTitle.includes('bug:')) {
              labels.push('bug', 'bugfix');
            }
            if (prTitle.includes('docs:') || prTitle.includes('documentation:')) {
              labels.push('documentation');
            }
            if (prTitle.includes('chore:') || prTitle.includes('deps:')) {
              labels.push('maintenance', 'dependencies');
            }
            if (prTitle.includes('ci:') || prTitle.includes('workflow:')) {
              labels.push('ci-cd', 'github-actions');
            }
            if (prTitle.includes('style:') || prTitle.includes('format:')) {
              labels.push('styling', 'code-quality');
            }
            if (prTitle.includes('perf:') || prTitle.includes('performance:')) {
              labels.push('performance', 'optimization');
            }
            if (prTitle.includes('refactor:')) {
              labels.push('refactoring', 'code-quality');
            }
            if (prTitle.includes('test:')) {
              labels.push('testing', 'quality-assurance');
            }
            
            // ğŸ“ File-based classification
            const changedFiles = files.data.map(f => f.filename);
            
            if (changedFiles.some(f => f.includes('.github/workflows/'))) {
              labels.push('ci-cd', 'github-actions');
            }
            if (changedFiles.some(f => f.includes('package.json') || f.includes('package-lock.json'))) {
              labels.push('dependencies');
            }
            if (changedFiles.some(f => f.includes('README') || f.includes('.md'))) {
              labels.push('documentation');
            }
            if (changedFiles.some(f => f.includes('test') || f.includes('spec'))) {
              labels.push('testing');
            }
            if (changedFiles.some(f => f.includes('docker') || f.includes('Docker'))) {
              labels.push('docker', 'infrastructure');
            }
            if (changedFiles.some(f => f.includes('scripts/'))) {
              labels.push('build-system', 'tooling');
            }
            if (changedFiles.some(f => f.includes('src/'))) {
              labels.push('core', 'source-code');
            }
            
            // ğŸ¨ Visual/UI changes
            if (changedFiles.some(f => f.includes('.css') || f.includes('.html') || f.includes('template'))) {
              labels.push('ui-ux', 'frontend');
            }
            
            // ğŸ“¦ Size classification
            const filesCount = changedFiles.length;
            if (filesCount <= 3) {
              labels.push('size: small');
            } else if (filesCount <= 10) {
              labels.push('size: medium');
            } else {
              labels.push('size: large');
            }
            
            // ğŸš¨ Breaking changes detection
            if (prTitle.includes('breaking') || prTitle.includes('!:') || prBody.includes('BREAKING CHANGE')) {
              labels.push('breaking-change', 'major-version');
            }
            
            // ğŸ”„ PR type classification
            if (context.payload.pull_request.draft) {
              labels.push('work-in-progress', 'draft');
            } else {
              labels.push('ready-for-review');
            }
            
            // ğŸ¯ Priority detection
            if (prTitle.includes('hotfix') || prTitle.includes('urgent') || prTitle.includes('critical')) {
              labels.push('priority: high', 'urgent');
            } else if (prTitle.includes('feat:') || prTitle.includes('feature:')) {
              labels.push('priority: medium');
            } else {
              labels.push('priority: normal');
            }
            
            // Apply labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: [...new Set(labels)]  // Remove duplicates
              });
              
              console.log(`Applied labels: ${labels.join(', ')}`);
            }

  # ğŸ”„ Auto-merge for Dependabot and Trusted Automation
  auto-merge:
    name: ğŸ”„ Smart Auto-Merge
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && (github.actor == 'dependabot[bot]' || github.actor == 'github-actions[bot]')
    continue-on-error: true  # Non-blocking
    
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Wait for status checks
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;
            
            // Wait up to 10 minutes for checks to complete
            const maxWaitTime = 10 * 60 * 1000; // 10 minutes
            const checkInterval = 30 * 1000; // 30 seconds
            const startTime = Date.now();
            
            while (Date.now() - startTime < maxWaitTime) {
              try {
                const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                
                // Check if PR is mergeable and all checks pass
                if (pr.mergeable && pr.mergeable_state === 'clean') {
                  console.log('âœ… All checks passed, PR ready for auto-merge');
                  
                  // Auto-merge with conventional commit message
                  const mergeTitle = `${pr.title}`;
                  const mergeMessage = `${pr.body || 'Automated dependency update'}\n\nğŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\nCo-Authored-By: ${context.actor} <noreply@github.com>`;

                  await github.rest.pulls.merge({
                    owner,
                    repo,
                    pull_number: prNumber,
                    commit_title: mergeTitle,
                    commit_message: mergeMessage,
                    merge_method: 'squash'
                  });
                  
                  console.log('âœ… PR auto-merged successfully');
                  return;
                }
                
                if (pr.mergeable_state === 'dirty' || pr.mergeable_state === 'unstable') {
                  console.log('âŒ PR has conflicts or failing checks, cannot auto-merge');
                  return;
                }
                
                console.log(`â³ Waiting for checks... (${pr.mergeable_state})`);
                await new Promise(resolve => setTimeout(resolve, checkInterval));
              } catch (error) {
                console.log(`Error checking PR status: ${error.message}`);
                await new Promise(resolve => setTimeout(resolve, checkInterval));
              }
            }
            
            console.log('â° Timeout waiting for checks, skipping auto-merge');

  # ğŸ§¹ PR Maintenance & Cleanup
  pr-maintenance:
    name: ğŸ§¹ PR Maintenance Bot
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    continue-on-error: true  # Non-blocking
    
    steps:
      - name: Stale PR management
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            
            // Get all open PRs
            const { data: prs } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              sort: 'updated',
              direction: 'asc'
            });
            
            const now = new Date();
            const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            const fourteenDaysAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
            
            for (const pr of prs) {
              const lastUpdated = new Date(pr.updated_at);
              
              // Skip Dependabot PRs and release PRs
              if (pr.user.login === 'dependabot[bot]' || pr.head.ref.startsWith('release-please--')) {
                continue;
              }
              
              // Mark stale PRs (7+ days)
              if (lastUpdated < sevenDaysAgo && !pr.labels.some(l => l.name === 'stale')) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: pr.number,
                  labels: ['stale', 'needs-attention']
                });
                
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr.number,
                  body: `## ğŸ•’ Stale PR Notice\n\nThis PR has been inactive for 7+ days and has been marked as stale.\n\n### Next Steps:\n- ğŸ“ **Review and update** if still relevant\n- ğŸ”„ **Rebase** if there are conflicts\n- ğŸš€ **Request review** if ready to merge\n- âŒ **Close** if no longer needed\n\nThe PR will be automatically closed after 14 days of inactivity.\n\n*Generated by PR Maintenance Bot - ${new Date().toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'})} BRT*`
                });
              }
              
              // Close very stale PRs (14+ days)
              if (lastUpdated < fourteenDaysAgo && pr.labels.some(l => l.name === 'stale')) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr.number,
                  body: `## ğŸ”’ Auto-Closing Stale PR\n\nThis PR has been inactive for 14+ days and is being automatically closed.\n\nIf this PR is still relevant, please:\n1. Reopen the PR\n2. Rebase on the latest main branch\n3. Address any conflicts or feedback\n\n*Generated by PR Maintenance Bot - ${new Date().toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'})} BRT*`
                });
                
                await github.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: pr.number,
                  state: 'closed'
                });
                
                console.log(`Closed stale PR #${pr.number}: ${pr.title}`);
              }
            }

  # ğŸ¯ Comment Command Handler
  command-handler:
    name: ğŸ¯ PR Command Handler
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    continue-on-error: true  # Non-blocking
    
    steps:
      - name: Handle PR commands
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const comment = context.payload.comment.body.toLowerCase().trim();
            const prNumber = context.payload.issue.number;
            
            // Only respond to maintainer commands
            if (!['rafilkmp3', 'github-actions[bot]'].includes(context.actor)) {
              return;
            }
            
            if (comment === '/rerun-checks') {
              // Trigger workflow re-run by updating PR
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: `ğŸ”„ **Re-running checks...**\n\nTriggered by: @${context.actor}\nTime: ${new Date().toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'})} BRT\n\nAll CI/CD workflows will be retriggered for this PR.`
              });
            }
            
            if (comment === '/merge') {
              // Attempt to merge PR
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              
              if (pr.mergeable && pr.mergeable_state === 'clean') {
                const mergeTitle = pr.title;
                const mergeMessage = `${pr.body || 'Manual merge via PR command'}\n\nğŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\nCo-Authored-By: ${context.actor} <noreply@github.com>`;

                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: prNumber,
                  commit_title: mergeTitle,
                  commit_message: mergeMessage,
                  merge_method: 'squash'
                });
                
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: `âœ… **PR merged successfully!**\n\nMerged by: @${context.actor}\nTime: ${new Date().toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'})} BRT`
                });
              } else {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: `âŒ **Cannot merge PR**\n\nReason: PR is not in a mergeable state (${pr.mergeable_state})\nPlease ensure all checks pass and there are no conflicts.`
                });
              }
            }
            
            if (comment.startsWith('/label ')) {
              const labelsToAdd = comment.replace('/label ', '').split(' ').filter(l => l.length > 0);
              
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: labelsToAdd
              });
              
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: `ğŸ·ï¸ **Labels added:** ${labelsToAdd.join(', ')}\n\nAdded by: @${context.actor}\nTime: ${new Date().toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'})} BRT`
              });
            }

# ğŸš€ INTELLIGENT PR AUTOMATION SUMMARY
#
# ğŸ¤– Advanced Bot Features:
# - ğŸ·ï¸ Smart labeling based on conventional commits and file changes
# - ğŸ”„ Auto-merge for trusted bots (Dependabot, GitHub Actions)
# - ğŸ§¹ Automated stale PR management with BRT timezone
# - ğŸ¯ Comment commands (/rerun-checks, /merge, /label)
#
# ğŸ“… BRT Optimized Schedule:
# - Weekdays 8 AM BRT: Daily PR maintenance and cleanup
# - Real-time: Label assignment and auto-merge for bot PRs
# - Stale detection: 7 days warning, 14 days auto-close
#
# âœ… Conventional Commits Compliance:
# - All automated commits follow conventional commit format
# - Proper commit messages with scope and description
# - Claude Code attribution and co-authoring
# - Enterprise-grade commit metadata
