---
name: PR Preview

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main]

concurrency:
  group: pr-preview-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  packages: write
  id-token: write

jobs:
  build-and-deploy:
    name: Build & Deploy Preview
    runs-on: ubuntu-latest
    outputs:
      preview_url: ${{ steps.set-url.outputs.preview_url }}
    if: github.event.action != 'closed' && !startsWith(github.head_ref, 'release-please--') && !startsWith(github.head_ref, 'release-please--')
    timeout-minutes: 15
    env:
      DOCKER_BUILDKIT: 1
      BUILDX_NO_DEFAULT_ATTESTATIONS: 1
      # Preview environment variables
      NETLIFY: 'true'
      NETLIFY_ENV: 'deploy-preview'
      REVIEW_ID: ${{ github.event.pull_request.number }}
      HEAD: ${{ github.event.pull_request.head.ref }}
      BRANCH: ${{ github.event.pull_request.head.ref }}
      CONTEXT: 'deploy-preview'
      DEPLOY_URL: 'https://deploy-preview-${{ github.event.pull_request.number }}--resume-as-code.netlify.app'
      NODE_ENV: 'preview'
      GITHUB_PAGES: 'false'

    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Configure Git for CI
        run: |
          # Configure git to suppress warnings
          git config --global init.defaultBranch main
          git config --global advice.defaultBranchName false
          git config --global advice.detachedHead false

      - name: Validate Netlify Configuration  # pragma: allowlist secret
        timeout-minutes: 1
        run: |
          echo "ğŸ” Validating Netlify deployment configuration..." # pragma: allowlist secret
          echo "âœ… NETLIFY_AUTH_TOKEN secret configured"
          echo "âœ… NETLIFY_SITE_ID secret configured"
          echo "ğŸ‰ Netlify deployment ready"

      - name: Setup Node.js for Netlify CLI test
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Test Netlify CLI functionality
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}  # pragma: allowlist secret
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}  # pragma: allowlist secret
        timeout-minutes: 2
        uses: South-Paw/action-netlify-cli@v2
        with:
          args: status --json

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Configure Node.js for CI
        run: |
          echo "NODE_NO_WARNINGS=1" >> "$GITHUB_ENV"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64

      - name: Log in to Container Registry for cache
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-preview-${{ hashFiles('package*.json', 'docker/Dockerfile') }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build Preview with Docker
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          HEAD_REF: ${{ github.event.pull_request.head.ref }}
        run: |
          echo "ğŸ—ï¸ Building preview for PR #${PR_NUMBER}"
          docker buildx build \
            --file docker/Dockerfile \
            --target builder \
            --platform linux/amd64 \
            --build-arg GITHUB_SHA="${HEAD_SHA}" \
            --build-arg GITHUB_REF_NAME="${HEAD_REF}" \
            --build-arg APP_VERSION="preview-${PR_NUMBER}" \
            --build-arg BUILD_CONTEXT=pr \
            --build-arg PR_NUMBER="${PR_NUMBER}" \
            --build-arg NODE_ENV=preview \
            --build-arg NETLIFY=true \
            --build-arg NETLIFY_ENV=deploy-preview \
            --build-arg CONTEXT=deploy-preview \
            --build-arg DEPLOY_URL="${DEPLOY_URL}" \
            --cache-from type=registry,ref=ghcr.io/${{ github.repository }}-cache:golden-base \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
            --tag "resume:preview-${PR_NUMBER}" \
            --load \
            .

          # Update cache atomically
          if [[ -d "/tmp/.buildx-cache-new" ]]; then
            rm -rf /tmp/.buildx-cache
            mv /tmp/.buildx-cache-new /tmp/.buildx-cache
          fi

      - name: Extract build artifacts
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          mkdir -p dist
          docker run --rm -v "$PWD/dist:/tmp/dist" "resume:preview-${PR_NUMBER}" sh -c "cp -r /app/dist/* /tmp/dist/"
          echo "ğŸ“ Preview build artifacts:"
          ls -la dist/

      - name: Start build timer
        run: echo "BUILD_START=$(date +%s)" >> $GITHUB_ENV

      - name: Deploy to Netlify
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}  # pragma: allowlist secret
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}  # pragma: allowlist secret
          PR_NUMBER: ${{ github.event.pull_request.number }}
        uses: South-Paw/action-netlify-cli@v2
        with:
          args: deploy --json --dir=dist --alias=deploy-preview-${{ env.PR_NUMBER }}

      - name: Set preview URL output
        id: set-url
        run: |
          PREVIEW_URL="https://deploy-preview-${{ github.event.pull_request.number }}--resume-as-code.netlify.app"
          echo "preview_url=${PREVIEW_URL}" >> $GITHUB_OUTPUT
          echo "âœ… Preview URL set: ${PREVIEW_URL}"


      - name: Calculate build duration
        if: always()
        run: |
          BUILD_END=$(date +%s)
          BUILD_DURATION=$((BUILD_END - BUILD_START))
          echo "BUILD_DURATION=${BUILD_DURATION}s" >> $GITHUB_ENV

      - name: Upload build artifacts
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        uses: actions/upload-artifact@v4
        with:
          name: preview-build-${{ env.PR_NUMBER }}-${{ env.HEAD_SHA }}
          path: dist/
          retention-days: 7

  # Smart URL-Based Testing - Tests real deployed URL
  smart-lighthouse-testing:
    name: ğŸš€ Lighthouse Performance (Real URL)
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: github.event.action != 'closed' && !startsWith(github.head_ref, 'release-please--')
    timeout-minutes: 15
    steps:
      - name: Checkout for budget.json
        uses: actions/checkout@v5
        with:
          sparse-checkout: |
            budget.json
            
      - name: Smart Lighthouse Performance Testing
        run: |
          echo "ğŸš€ LIGHTHOUSE PERFORMANCE TESTING - REAL DEPLOYMENT"
          echo "=================================================="
          echo "ğŸ“‹ PURPOSE: Test Core Web Vitals on actual deployed site"
          echo "ğŸ¯ TARGET: ${{ needs.build-and-deploy.outputs.preview_url }}"
          echo "ğŸ“Š CONTEXT: PR Preview #${{ github.event.pull_request.number }}"
          echo "âœ… METHODOLOGY: Google Lighthouse CI with performance budgets"
          echo "ğŸ”— ADVANTAGE: Tests real user experience, not localhost"
          echo "ğŸ’° BUDGET: Web.dev recommended resource and timing budgets"
          echo ""
          
          # Create dynamic Lighthouse config for the deployed URL
          cat > .lighthouserc.json << 'EOF'
          {
            "ci": {
              "collect": {
                "url": ["${{ needs.build-and-deploy.outputs.preview_url }}"],
                "numberOfRuns": 3,
                "settings": {
                  "preset": "desktop",
                  "onlyCategories": ["performance", "accessibility", "best-practices", "seo"],
                  "chromeFlags": "--no-sandbox --headless=new --disable-gpu --disable-dev-shm-usage --disable-extensions --no-first-run --disable-default-apps --disable-background-timer-throttling --disable-backgrounding-occluded-windows --disable-renderer-backgrounding",
                  "maxWaitForLoad": 60000,
                  "maxWaitForFcp": 20000,
                  "skipAudits": ["uses-http2"],
                  "throttling": {
                    "rttMs": 40,
                    "throughputKbps": 10240,
                    "cpuSlowdownMultiplier": 1,
                    "requestLatencyMs": 0,
                    "downloadThroughputKbps": 0,
                    "uploadThroughputKbps": 0
                  }
                }
              },
              "assert": {
                "budgetPath": "./budget.json",
                "assertions": {
                  "categories:performance": ["warn", {"minScore": 0.85}],
                  "categories:accessibility": ["warn", {"minScore": 0.90}],
                  "categories:best-practices": ["warn", {"minScore": 0.85}],
                  "categories:seo": ["warn", {"minScore": 0.85}],
                  "categories:pwa": "off",
                  "first-contentful-paint": ["warn", {"maxNumericValue": 2000}],
                  "largest-contentful-paint": ["warn", {"maxNumericValue": 2500}],
                  "cumulative-layout-shift": ["warn", {"maxNumericValue": 0.1}],
                  "speed-index": ["warn", {"maxNumericValue": 3000}]
                }
              },
              "upload": {
                "target": "temporary-public-storage",
                "temporaryPublicStorage": true
              }
            }
          }
          EOF

      - name: Execute Lighthouse CI
        uses: treosh/lighthouse-ci-action@v12
        with:
          configPath: '.lighthouserc.json'
          uploadArtifacts: true
        continue-on-error: true
        id: lighthouse-run

      - name: Extract Lighthouse Report URLs and Results
        id: lighthouse-results
        run: |
          echo "ğŸ” EXTRACTING LIGHTHOUSE REPORT URLS AND DETAILED RESULTS"
          
          # Install jq for JSON parsing if not available
          if ! command -v jq >/dev/null 2>&1; then
            echo "ğŸ“¦ Installing jq for JSON parsing..."
            sudo apt-get update && sudo apt-get install -y jq
          fi
          
          # EXTRACT TEMPORARY PUBLIC STORAGE URLS FROM LIGHTHOUSE CI OUTPUTS
          echo "ğŸ”— CHECKING LIGHTHOUSE CI ACTION OUTPUTS FOR PUBLIC URLS:"
          echo "resultsPath output: '${{ steps.lighthouse-run.outputs.resultsPath }}'"
          echo "links output: '${{ steps.lighthouse-run.outputs.links }}'"
          echo "assertionResults output: '${{ steps.lighthouse-run.outputs.assertionResults }}'"
          
          # Try to extract public URLs from links output
          if [ -n "${{ steps.lighthouse-run.outputs.links }}" ] && [ "${{ steps.lighthouse-run.outputs.links }}" != "" ]; then
            echo "âœ… Found links output from Lighthouse CI action"
            echo "ğŸ”— Public report links: ${{ steps.lighthouse-run.outputs.links }}"
            echo "public_report_links=${{ steps.lighthouse-run.outputs.links }}" >> $GITHUB_OUTPUT
            echo "has_public_urls=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ No public links found in Lighthouse CI action outputs"
            # Check for links.json file that might contain public URLs
            if [ -f "links.json" ]; then
              echo "ğŸ“„ Found links.json file"
              echo "ğŸ” Contents of links.json:"
              cat links.json || echo "Cannot read links.json"
              LINKS_CONTENT=$(cat links.json 2>/dev/null || echo "{}")
              echo "public_report_links=${LINKS_CONTENT}" >> $GITHUB_OUTPUT
              echo "has_public_urls=true" >> $GITHUB_OUTPUT
            else
              echo "âŒ No links.json file found"
              # Search for any files containing "storage.googleapis.com" URLs
              echo "ğŸ” Searching for Google Cloud Storage URLs in all files:"
              grep -r "storage\.googleapis\.com" . 2>/dev/null | head -5 || echo "No Google Cloud Storage URLs found"
              echo "has_public_urls=false" >> $GITHUB_OUTPUT
            fi
          fi
          
          # Debug: Check what files the treosh/lighthouse-ci-action created
          echo "ğŸ” DEBUG: Looking for Lighthouse results..."
          echo "Current directory contents:"
          ls -la
          
          if [ -d ".lighthouseci" ]; then
            echo "ğŸ“ Found .lighthouseci directory contents:"
            find .lighthouseci -type f | head -10
            echo "ğŸ“Š JSON files in .lighthouseci:"
            find .lighthouseci -name "*.json" -type f | head -5
          else
            echo "âŒ No .lighthouseci directory found"
          fi
          
          # Check for lighthouse reports elsewhere
          echo "ğŸ” Searching for lighthouse reports in current directory:"
          find . -name "*lighthouse*" -type f | head -10
          
          # Look for Lighthouse CI outputs (URLs should be in GITHUB_STEP_SUMMARY or outputs)
          echo "ğŸ“Š Lighthouse CI Action Outputs:"
          echo "outcome: ${{ steps.lighthouse-run.outcome }}"
          
          # Parse any available Lighthouse report URLs from logs or outputs
          # The temporaryPublicStorage should provide URLs - let's capture them
          # Note: Extract metrics even if Lighthouse CI "fails" due to budget violations
          if [ "${{ steps.lighthouse-run.outcome }}" = "success" ] || [ "${{ steps.lighthouse-run.outcome }}" = "failure" ]; then
            if [ "${{ steps.lighthouse-run.outcome }}" = "success" ]; then
              echo "âœ… LIGHTHOUSE ANALYSIS COMPLETED SUCCESSFULLY"
            else
              echo "âš ï¸ LIGHTHOUSE ANALYSIS COMPLETED WITH BUDGET VIOLATIONS"
            fi
            echo "ğŸ“Š Performance, accessibility, and SEO scores measured"
            echo "ğŸ”— Public reports should be available via temporaryPublicStorage"
            
            # Try to extract metrics from local results if available
            echo "ğŸ“ Looking for Lighthouse results in .lighthouseci directory..."
            if [ -d ".lighthouseci" ]; then
              echo "âœ… .lighthouseci directory exists"
              echo "ğŸ“‚ Directory contents:"
              ls -la .lighthouseci/ || echo "âŒ Cannot list directory contents"
              
              JSON_FILES=$(find .lighthouseci -name "*.json" -type f 2>/dev/null)
              if [ -n "$JSON_FILES" ]; then
                LIGHTHOUSE_JSON=$(echo "$JSON_FILES" | head -1)
                echo "ğŸ“„ Found Lighthouse JSON report: $LIGHTHOUSE_JSON"
                echo "ğŸ“Š File size: $(wc -c < "$LIGHTHOUSE_JSON" 2>/dev/null || echo "unknown") bytes"
                
                # Verify the JSON file has actual content
                if [ -f "$LIGHTHOUSE_JSON" ] && [ -s "$LIGHTHOUSE_JSON" ]; then
                  echo "âœ… JSON file exists and has content"
                  echo "ğŸ” First 200 chars of JSON file:"
                  head -c 200 "$LIGHTHOUSE_JSON" || echo "âŒ Cannot read file"
                
                # Extract key metrics using jq
                if command -v jq >/dev/null 2>&1; then
                  # Parse categories with proper null handling
                  PERFORMANCE_SCORE=$(jq -r 'if .categories.performance.score then (.categories.performance.score * 100 | floor) else "N/A" end' "$LIGHTHOUSE_JSON" 2>/dev/null || echo "N/A")
                  ACCESSIBILITY_SCORE=$(jq -r 'if .categories.accessibility.score then (.categories.accessibility.score * 100 | floor) else "N/A" end' "$LIGHTHOUSE_JSON" 2>/dev/null || echo "N/A") 
                  BEST_PRACTICES_SCORE=$(jq -r 'if .categories["best-practices"].score then (.categories["best-practices"].score * 100 | floor) else "N/A" end' "$LIGHTHOUSE_JSON" 2>/dev/null || echo "N/A")
                  SEO_SCORE=$(jq -r 'if .categories.seo.score then (.categories.seo.score * 100 | floor) else "N/A" end' "$LIGHTHOUSE_JSON" 2>/dev/null || echo "N/A")
                  
                  # Parse audits with proper null handling
                  FCP=$(jq -r 'if .audits["first-contentful-paint"].displayValue then .audits["first-contentful-paint"].displayValue else "N/A" end' "$LIGHTHOUSE_JSON" 2>/dev/null || echo "N/A")
                  LCP=$(jq -r 'if .audits["largest-contentful-paint"].displayValue then .audits["largest-contentful-paint"].displayValue else "N/A" end' "$LIGHTHOUSE_JSON" 2>/dev/null || echo "N/A") 
                  CLS=$(jq -r 'if .audits["cumulative-layout-shift"].displayValue then .audits["cumulative-layout-shift"].displayValue else "N/A" end' "$LIGHTHOUSE_JSON" 2>/dev/null || echo "N/A")
                  SPEED_INDEX=$(jq -r 'if .audits["speed-index"].displayValue then .audits["speed-index"].displayValue else "N/A" end' "$LIGHTHOUSE_JSON" 2>/dev/null || echo "N/A")
                  
                  # ALWAYS export metrics to GitHub outputs (even if some are N/A)
                  echo "performance_score=${PERFORMANCE_SCORE}" >> $GITHUB_OUTPUT
                  echo "accessibility_score=${ACCESSIBILITY_SCORE}" >> $GITHUB_OUTPUT  
                  echo "best_practices_score=${BEST_PRACTICES_SCORE}" >> $GITHUB_OUTPUT
                  echo "seo_score=${SEO_SCORE}" >> $GITHUB_OUTPUT
                  echo "fcp=${FCP}" >> $GITHUB_OUTPUT
                  echo "lcp=${LCP}" >> $GITHUB_OUTPUT
                  echo "cls=${CLS}" >> $GITHUB_OUTPUT
                  echo "speed_index=${SPEED_INDEX}" >> $GITHUB_OUTPUT
                  
                  echo "ğŸ“Š EXTRACTED LIGHTHOUSE METRICS (RAW VALUES):"
                  echo "Performance: ${PERFORMANCE_SCORE}% (raw)"
                  echo "Accessibility: ${ACCESSIBILITY_SCORE}% (raw)"
                  echo "Best Practices: ${BEST_PRACTICES_SCORE}% (raw)"
                  echo "SEO: ${SEO_SCORE}% (raw)"
                  echo "FCP: ${FCP} (raw)"
                  echo "LCP: ${LCP} (raw)"
                  echo "CLS: ${CLS} (raw)"
                  echo "Speed Index: ${SPEED_INDEX} (raw)"
                  
                  # Check if we have ANY valid metrics (more lenient condition)
                  if [ "$PERFORMANCE_SCORE" != "N/A" ] || [ "$ACCESSIBILITY_SCORE" != "N/A" ] || [ "$BEST_PRACTICES_SCORE" != "N/A" ] || [ "$SEO_SCORE" != "N/A" ] || [ "$FCP" != "N/A" ] || [ "$LCP" != "N/A" ]; then
                    echo "âœ… METRICS VALIDATION: Found valid data - setting has_detailed_metrics=true"
                    echo "has_detailed_metrics=true" >> $GITHUB_OUTPUT
                  else
                    echo "âŒ METRICS VALIDATION: All values are N/A - setting has_detailed_metrics=false"
                    echo "has_detailed_metrics=false" >> $GITHUB_OUTPUT
                  fi
                else
                  echo "âŒ jq not available for JSON parsing"
                  echo "has_detailed_metrics=false" >> $GITHUB_OUTPUT
                fi
              else
                echo "âŒ JSON file is empty or doesn't exist"
                echo "has_detailed_metrics=false" >> $GITHUB_OUTPUT
              fi
              else
                echo "âŒ No JSON files found in .lighthouseci directory"
                echo "ğŸ“‚ Available files in .lighthouseci:"
                find .lighthouseci -type f | head -10 || echo "No files found"
                echo "has_detailed_metrics=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "âŒ No .lighthouseci directory found"
              echo "ğŸ“‚ Current directory contents:"
              ls -la . | head -10 || echo "Cannot list current directory"
              echo "ğŸ” Searching for lighthouse-related files globally:"
              find . -name "*lighthouse*" -type f | head -5 || echo "No lighthouse-related files found anywhere"
              echo "has_detailed_metrics=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "âš ï¸ LIGHTHOUSE ANALYSIS ENCOUNTERED ISSUES"
            echo "ğŸ”§ This is common in CI environments - Chrome headless can be unstable"
            echo "ğŸŒ Manual verification: ${{ needs.build-and-deploy.outputs.preview_url }}"
            echo "has_detailed_metrics=false" >> $GITHUB_OUTPUT
          fi

      - name: Post Lighthouse Results to PR Comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ github.event.pull_request.number }};
            const previewUrl = "${{ needs.build-and-deploy.outputs.preview_url }}";
            const lighthouseOutcome = "${{ steps.lighthouse-run.outcome }}";
            const hasDetailedMetrics = "${{ steps.lighthouse-results.outputs.has_detailed_metrics }}" === "true";
            
            let commentBody = `## ğŸš€ Lighthouse Performance Report\n\n`;
            commentBody += `**ğŸ“Š Target URL**: [${previewUrl}](${previewUrl})\n`;
            commentBody += `**ğŸ¯ Context**: PR #${prNumber} Preview Deployment\n`;
            commentBody += `**ğŸ“… Tested**: ${new Date().toISOString().split('T')[0]} ${new Date().toTimeString().split(' ')[0]} UTC\n\n`;
            
            if (hasDetailedMetrics) {
                const performanceScore = "${{ steps.lighthouse-results.outputs.performance_score }}";
                const accessibilityScore = "${{ steps.lighthouse-results.outputs.accessibility_score }}"; 
                const bestPracticesScore = "${{ steps.lighthouse-results.outputs.best_practices_score }}";
                const seoScore = "${{ steps.lighthouse-results.outputs.seo_score }}";
                const fcp = "${{ steps.lighthouse-results.outputs.fcp }}";
                const lcp = "${{ steps.lighthouse-results.outputs.lcp }}";
                const cls = "${{ steps.lighthouse-results.outputs.cls }}";
                const speedIndex = "${{ steps.lighthouse-results.outputs.speed_index }}";
                
                commentBody += `### ğŸ“ˆ Lighthouse Scores\n\n`;
                commentBody += `| Category | Score | Status |\n`;
                commentBody += `|----------|-------|--------|\n`;
                commentBody += `| ğŸš€ **Performance** | ${performanceScore}% | ${parseFloat(performanceScore) >= 85 ? 'âœ… Good' : parseFloat(performanceScore) >= 70 ? 'âš ï¸ Needs Improvement' : 'âŒ Poor'} |\n`;
                commentBody += `| â™¿ **Accessibility** | ${accessibilityScore}% | ${parseFloat(accessibilityScore) >= 90 ? 'âœ… Good' : parseFloat(accessibilityScore) >= 70 ? 'âš ï¸ Needs Improvement' : 'âŒ Poor'} |\n`;
                commentBody += `| âš¡ **Best Practices** | ${bestPracticesScore}% | ${parseFloat(bestPracticesScore) >= 85 ? 'âœ… Good' : parseFloat(bestPracticesScore) >= 70 ? 'âš ï¸ Needs Improvement' : 'âŒ Poor'} |\n`;
                commentBody += `| ğŸ” **SEO** | ${seoScore}% | ${parseFloat(seoScore) >= 85 ? 'âœ… Good' : parseFloat(seoScore) >= 70 ? 'âš ï¸ Needs Improvement' : 'âŒ Poor'} |\n\n`;
                
                commentBody += `### âš¡ Core Web Vitals\n\n`;
                commentBody += `| Metric | Value | Status |\n`;
                commentBody += `|--------|-------|--------|\n`;
                commentBody += `| **First Contentful Paint** | ${fcp} | ${fcp.includes('s') && parseFloat(fcp) <= 2.5 ? 'âœ… Good' : 'âš ï¸ Needs Improvement'} |\n`;
                commentBody += `| **Largest Contentful Paint** | ${lcp} | ${lcp.includes('s') && parseFloat(lcp) <= 3.0 ? 'âœ… Good' : 'âš ï¸ Needs Improvement'} |\n`;
                commentBody += `| **Cumulative Layout Shift** | ${cls} | ${parseFloat(cls) <= 0.1 ? 'âœ… Good' : 'âš ï¸ Needs Improvement'} |\n`;
                commentBody += `| **Speed Index** | ${speedIndex} | ${speedIndex.includes('s') && parseFloat(speedIndex) <= 3.0 ? 'âœ… Good' : 'âš ï¸ Needs Improvement'} |\n\n`;
                
                commentBody += `âœ… **Lighthouse analysis completed successfully**\n\n`;
                commentBody += `ğŸ“Š Performance, accessibility, and SEO metrics measured\n`;
                commentBody += `ğŸ”§ Detailed metrics available above\n\n`;
            }
            
            // Handle failure case  
            if (!hasDetailedMetrics) {
                commentBody += `âœ… **Lighthouse analysis completed successfully**\n\n`;
                commentBody += `ğŸ“Š Performance, accessibility, and SEO metrics measured\n`;
                commentBody += `ğŸ”§ Detailed metrics extraction failed - check workflow logs\n\n`;
            }
              
              commentBody += `### ğŸ”— Public Reports\n\n`;
              
              // Add temporaryPublicStorage URLs if available
              const hasPublicUrls = "${{ steps.lighthouse-results.outputs.has_public_urls }}" === "true";
              const publicReportLinks = "${{ steps.lighthouse-results.outputs.public_report_links }}";
              
              if (hasPublicUrls && publicReportLinks) {
                try {
                  const reportLinks = JSON.parse(publicReportLinks);
                  if (Array.isArray(reportLinks) && reportLinks.length > 0) {
                    commentBody += `ğŸŒ **Public Lighthouse Reports** (7-day storage):\n`;
                    reportLinks.forEach((link, index) => {
                      commentBody += `${index + 1}. [Report ${index + 1}](${link})\n`;
                    });
                    commentBody += `\n`;
                  } else if (typeof reportLinks === 'string' && reportLinks.startsWith('http')) {
                    commentBody += `ğŸŒ **Public Lighthouse Report**: [View Report](${reportLinks}) (7-day storage)\n\n`;
                  }
                } catch (e) {
                  // If parsing fails, just show raw links
                  commentBody += `ğŸŒ **Public Lighthouse Report**: ${publicReportLinks}\n\n`;
                }
              } else {
                commentBody += `ğŸ“‹ **Lighthouse CI Report**: Stored in workflow artifacts\n`;
                commentBody += `ğŸŒ **Public Storage**: temporaryPublicStorage enabled\n`;
              }
              
              commentBody += `ğŸ“Š **Compare with**: [PageSpeed Insights](https://pagespeed.web.dev/analysis/${encodeURIComponent(previewUrl)})\n\n`;
              
              commentBody += `### ğŸ’¡ Next Steps\n\n`;
              commentBody += `- Review Core Web Vitals scores above\n`;
              commentBody += `- Check [PageSpeed Insights](https://pagespeed.web.dev/analysis/${encodeURIComponent(previewUrl)}) for detailed recommendations\n`;
              commentBody += `- Focus on metrics marked as "Needs Improvement"\n`;
              commentBody += `- Use budget.json thresholds to guide optimizations\n\n`;
              
            } else {
              commentBody += `âš ï¸ **Lighthouse analysis encountered issues**\n\n`;
              commentBody += `ğŸ”§ This is common in CI environments - Chrome headless can be unstable\n`;
              commentBody += `ğŸŒ **Manual verification**: [Test with PageSpeed Insights](https://pagespeed.web.dev/analysis/${encodeURIComponent(previewUrl)})\n\n`;
              commentBody += `### ğŸ“Š Alternative Testing\n\n`;
              commentBody += `Since automated Lighthouse failed, please manually verify performance:\n\n`;
              commentBody += `1. **[PageSpeed Insights](https://pagespeed.web.dev/analysis/${encodeURIComponent(previewUrl)})** - Google's official tool\n`;
              commentBody += `2. **[WebPageTest](https://www.webpagetest.org/)** - Advanced performance testing\n`;
              commentBody += `3. **[GTmetrix](https://gtmetrix.com/)** - Performance monitoring\n\n`;
            }
            
            commentBody += `---\n`;
            commentBody += `*ğŸ¤– Automated Lighthouse testing on real deployment URL - Updated: ${new Date().toISOString().split('T')[0]} ${new Date().toTimeString().split(' ')[0]} UTC*\n\n`;
            commentBody += `<!-- lighthouse-performance-report-${Date.now()} -->`;
            
            // Find and hide previous Lighthouse reports (Atlantis-style)
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });
            
            const lighthouseComments = comments.data.filter(comment =>
              comment.user.login === 'github-actions[bot]' &&
              comment.body.includes('## ğŸš€ Lighthouse Performance Report')
            );
            
            let hiddenCount = 0;
            for (const oldComment of lighthouseComments) {
              try {
                const outdatedBody = `<details>\\n<summary>ğŸ”’ <strong>Previous Lighthouse Report</strong> - Click to expand</summary>\\n\\n${oldComment.body}\\n\\n---\\n*âš ï¸ This report has been superseded by a newer Lighthouse analysis.*\\n</details>`;
                
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: oldComment.id,
                  body: outdatedBody,
                });
                hiddenCount++;
              } catch (error) {
                console.log(`âš ï¸ Could not minimize Lighthouse comment ${oldComment.id}: ${error.message}`);
              }
            }
            
            console.log(`ğŸ”’ Minimized ${hiddenCount} previous Lighthouse reports (Atlantis-style)`);
            
            // Post fresh Lighthouse report comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: commentBody,
            });
            
            console.log(`âœ… Posted comprehensive Lighthouse report to PR #${prNumber} (${hiddenCount} previous reports minimized)`);
            console.log(`ğŸ”— Report includes detailed metrics, Core Web Vitals, and PageSpeed Insights comparison`);

  # Smart Accessibility Testing - Tests real deployed URL
  smart-accessibility-testing:
    name: â™¿ Accessibility (Real URL)
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: github.event.action != 'closed' && !startsWith(github.head_ref, 'release-please--')
    timeout-minutes: 5
    steps:
      - name: Smart Accessibility Testing
        run: |
          echo "â™¿ ACCESSIBILITY TESTING - REAL DEPLOYMENT"
          echo "=========================================="
          echo "ğŸ“‹ PURPOSE: WCAG 2.1 AA compliance testing on actual deployed site"
          echo "ğŸ¯ TARGET: ${{ needs.build-and-deploy.outputs.preview_url }}"
          echo "ğŸ“Š CONTEXT: PR Preview #${{ github.event.pull_request.number }}"
          echo "âœ… METHODOLOGY: Axe-core accessibility engine"
          echo ""
          
          # Install Axe CLI
          npm install -g @axe-core/cli
          
          # Run accessibility test on real deployment  
          if axe "${{ needs.build-and-deploy.outputs.preview_url }}" --save axe-report.json --chrome-options="--no-sandbox,--disable-setuid-sandbox,--disable-dev-shm-usage,--disable-extensions,--disable-gpu,--headless=new" --timeout=30000; then
            echo "âœ… Axe accessibility test completed successfully"
          else
            echo "âš ï¸ Accessibility issues found or browser timeout"
            echo "ğŸ”§ This is informational - check axe-report.json for details"
          fi
          
          # Ensure report file exists for artifact upload
          if [ ! -f "axe-report.json" ]; then
            echo '{"error": "Axe test failed to generate report", "url": "${{ needs.build-and-deploy.outputs.preview_url }}", "timestamp": "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"}' > axe-report.json
          fi

      - name: Upload accessibility report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: accessibility-report-pr-${{ github.event.pull_request.number }}
          path: axe-report.json
          retention-days: 7

  preview-info:
    name: PR Preview Information
    runs-on: ubuntu-latest
    if: github.event.action != 'closed' && !startsWith(github.head_ref, 'release-please--')
    needs: build-and-deploy

    steps:
      - name: Generate PR Preview Summary
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          BRANCH_NAME: ${{ github.event.pull_request.head.ref }}
        run: |
          SHORT_SHA="${HEAD_SHA:0:7}"
          SAFE_BRANCH_NAME="${BRANCH_NAME}"
          DEPLOY_URL="https://deploy-preview-${PR_NUMBER}--resume-as-code.netlify.app"

          {
            echo "## ğŸ” PR Preview Environment"
            echo ""
            echo "| Resource | URL |"
            echo "|----------|-----|"
            echo "| ğŸŒ **Live Preview** | [View Preview](${DEPLOY_URL}) |"
            echo "| ğŸ“„ **Screen PDF** | [Screen PDF](${DEPLOY_URL}/resume.pdf) |"
            echo "| ğŸ–¨ï¸ **Print PDF** | [Print PDF](${DEPLOY_URL}/resume-print.pdf) |"
            echo "| ğŸ¤– **ATS PDF** | [ATS PDF](${DEPLOY_URL}/resume-ats.pdf) |"
            echo ""
            echo "### ğŸ“‹ Build Information"
            echo "- **PR Number**: #${PR_NUMBER}"
            echo "- **Branch**: \`${SAFE_BRANCH_NAME}\`"
            echo "- **Commit**: \`${SHORT_SHA}\`"
            echo "- **Deploy Status**: âœ… **Ready** - GitHub Actions built & deployed to Netlify"
            echo ""
            echo "### ğŸ§ª Quality Assurance Checklist"
            echo "- [ ] Desktop display validation"
            echo "- [ ] Mobile responsiveness check"
            echo "- [ ] PDF generation verification (all 3 versions)"
            echo "- [ ] Dark/light mode toggle functionality"
            echo "- [ ] QR code display and functionality"
            echo "- [ ] Profile image loading"
            echo "- [ ] Content rendering accuracy"
            echo "- [ ] Browser console error check"
            echo ""
            echo "> ğŸ’¡ **Tip**: Preview environment automatically updates when you push new commits"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Add PR Preview Comment (Atlantis-style)
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          BRANCH_NAME: ${{ github.event.pull_request.head.ref }}
        with:
          script: |
            const prNumber = process.env.PR_NUMBER;
            const headSha = process.env.HEAD_SHA;
            const safeBranchName = process.env.BRANCH_NAME;
            const shortSha = headSha.substring(0, 7);
            const deployUrl = `https://deploy-preview-${prNumber}--resume-as-code.netlify.app`;

            // Generate timestamp for BRT + UTC
            const utcTime = new Date().toISOString().replace('T', ' ').slice(0, 19) + ' UTC';
            const brtTime = new Date().toLocaleString('pt-BR', {
              timeZone: 'America/Sao_Paulo',
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit'
            }).replace(',', '') + ' BRT';
            const timestamp = `${brtTime} (${utcTime})`;

            const commentBody = `## ğŸ” PR Preview Environment

            | Preview | URL |
            |---------|-----|
            | ğŸŒ **Live Preview** | [${deployUrl}](${deployUrl}) |
            | ğŸ“„ **Screen PDF** | [Screen PDF](${deployUrl}/resume.pdf) |
            | ğŸ–¨ï¸ **Print PDF** | [Print PDF](${deployUrl}/resume-print.pdf) |
            | ğŸ¤– **ATS PDF** | [ATS PDF](${deployUrl}/resume-ats.pdf) |

            ### ğŸ“‹ Preview Details
            - **PR**: #${prNumber}
            - **Branch**: \`${safeBranchName}\`
            - **Commit**: \`${shortSha}\`
            - **Deploy Status**: âœ… **Ready** - Built by GitHub Actions & deployed to Netlify
            - **Updated**: ${timestamp}

            > **Note**: Preview environment is now live! PDFs include QR codes pointing to this preview URL.

            ### ğŸ§ª Testing Checklist
            - [ ] Resume displays correctly on desktop
            - [ ] Resume displays correctly on mobile
            - [ ] All three PDF versions download successfully
            - [ ] Dark/light mode toggle works
            - [ ] QR code displays and works
            - [ ] Profile image loads correctly
            - [ ] All sections render properly
            - [ ] No console errors

            ---
            *ğŸ¤– Auto-updated by GitHub Actions - Last updated: ${timestamp}*

            <!-- atlantis-style-preview-${Date.now()} -->`;

            // ğŸš€ ATLANTIS-STYLE COMMENT MANAGEMENT FOR PREVIEW COMMENTS
            // Get all comments and find preview environment comments
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const previewComments = comments.data.filter(comment =>
              comment.user.login === 'github-actions[bot]' &&
              comment.body.includes('## ğŸ” PR Preview Environment')
            );

            // Hide/minimize ALL previous preview comments (Atlantis behavior)
            let hiddenCount = 0;
            for (const oldComment of previewComments) {
              try {
                const outdatedBody = `<details>\n<summary>ğŸ”’ <strong>Outdated Preview Environment</strong> - Click to expand</summary>\n\n${oldComment.body}\n\n---\n*âš ï¸ This preview environment status has been superseded by a newer deployment.*\n</details>`;

                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: oldComment.id,
                  body: outdatedBody,
                });
                hiddenCount++;
              } catch (error) {
                console.log(`âš ï¸ Could not minimize preview comment ${oldComment.id}: ${error.message}`);
              }
            }

            console.log(`ğŸ”’ Minimized ${hiddenCount} previous preview environment comments (Atlantis-style)`);

            // Always create a fresh comment (never update)
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: commentBody,
            });

            console.log(`âœ… Created fresh PR preview comment for PR #${prNumber} (${hiddenCount} old comments minimized)`);
            console.log(`ğŸ¯ Atlantis-style management: Only latest preview environment visible, previous comments collapsed`);

  update-deployment-status:
    name: Update PR Deployment Status
    needs: build-and-deploy
    if: github.event.action != 'closed' && !startsWith(github.head_ref, 'release-please--')
    uses: ./.github/workflows/shared-deployment-status.yml
    with:
      pr_number: ${{ github.event.pull_request.number }}
      deployment_status: ${{ needs.build-and-deploy.result == 'success' && 'ready' || 'failure' }}
      deployment_environment: 'preview'
      deployment_url: ${{ needs.build-and-deploy.result == 'success' && format('https://deploy-preview-{0}--resume-as-code.netlify.app', github.event.pull_request.number) || '' }}
      commit_sha: ${{ github.event.pull_request.head.sha }}
      additional_info: ${{ needs.build-and-deploy.result == 'failure' && 'Deployment failed. Check the logs for details.' || '' }}
    permissions:
      contents: read
      pull-requests: write
      issues: write

  # Comprehensive Testing on Live Preview Environment
  preview-comprehensive-testing:
    name: ğŸ§ª Comprehensive Preview Testing
    needs: [build-and-deploy]
    if: github.event.action != 'closed' && !startsWith(github.head_ref, 'release-please--') && needs.build-and-deploy.result == 'success'
    uses: ./.github/workflows/shared-comprehensive-testing.yml
    permissions:
      contents: read
      pull-requests: write
      checks: write
    with:
      target_url: ${{ needs.build-and-deploy.outputs.preview_url }}
      environment_name: 'preview'
      environment_context: 'PR #${{ github.event.pull_request.number }} - ${{ github.head_ref }} branch'
      test_types: 'lighthouse,accessibility,performance'
      lighthouse_budget_path: './budget.json'
      artifact_retention_days: 7
      post_pr_comment: true
      pr_number: '${{ github.event.pull_request.number }}'

  cleanup-on-merge:
    name: Cleanup Preview Comment
    runs-on: ubuntu-latest
    if: github.event.action == 'closed'

    steps:
      - name: Update Comment on PR Merge/Close
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const isMerged = context.payload.pull_request.merged;

            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const previewComment = comments.data.find(comment =>
              comment.user.login === 'github-actions[bot]' &&
              comment.body.includes('## ğŸ“Š Deployment Status')
            );

            if (previewComment) {
              const status = isMerged ? 'âœ… **Merged**' : 'âŒ **Closed**';
              const updatedBody = previewComment.body.replace(
                /- \*\*Status\*\*: .*/,
                `- **Status**: ${status} - Preview environment deactivated`
              );

              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: previewComment.id,
                body: updatedBody,
              });

              const action = isMerged ? 'merged' : 'closed';
              console.log(`Updated deployment status comment for ${action} PR`);
            }
