---
name: Release Please Maintenance

on:
  push:
    branches:
      - main
  schedule:
    # Run daily at 9 AM UTC to ensure release PRs stay current
    - cron: '0 9 * * *'
  workflow_dispatch:

jobs:
  maintain-release-pr:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update release-please PRs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ” Checking for release-please PRs that need updates..."

          # Find all open release-please PRs with retry mechanism
          RELEASE_PRS=""
          for attempt in 1 2 3; do
            if RELEASE_PRS=$(gh pr list --label "autorelease: pending" --json number,title,headRefName,mergeable 2>/dev/null); then
              echo "âœ… Successfully retrieved PR data (attempt $attempt)"
              break
            else
              echo "âš ï¸ Failed to retrieve PR data (attempt $attempt)"
              if [ $attempt -eq 3 ]; then
                echo "âŒ All PR retrieval attempts failed, workflow will exit gracefully"
                echo "â„¹ï¸ This is a temporary issue - workflow can be retried later"
                exit 0
              else
                sleep $((attempt * 2))
              fi
            fi
          done

          # Validate JSON data before processing
          if ! echo "$RELEASE_PRS" | jq . >/dev/null 2>&1; then
            echo "âŒ Invalid JSON data received from GitHub API, exiting gracefully"
            exit 0
          fi

          PR_COUNT=$(echo "$RELEASE_PRS" | jq '. | length' 2>/dev/null || echo "0")
          if [ "$PR_COUNT" -eq 0 ]; then
            echo "â„¹ï¸ No release-please PRs found"
            exit 0
          fi

          echo "ðŸ“‹ Found $PR_COUNT release-please PRs to process"

          echo "$RELEASE_PRS" | jq -r '.[] | @json' | while IFS= read -r pr_json; do
            # Extract PR data with validation
            if ! PR_NUMBER=$(echo "$pr_json" | jq -r '.number' 2>/dev/null) || [ "$PR_NUMBER" = "null" ]; then
              echo "âš ï¸ Skipping PR with invalid number data"
              continue
            fi
            
            PR_TITLE=$(echo "$pr_json" | jq -r '.title' 2>/dev/null || echo "Unknown Title")
            PR_BRANCH=$(echo "$pr_json" | jq -r '.headRefName' 2>/dev/null || echo "unknown-branch")
            PR_MERGEABLE=$(echo "$pr_json" | jq -r '.mergeable' 2>/dev/null || echo "UNKNOWN")

            echo "ðŸ“‹ Processing release PR #$PR_NUMBER: $PR_TITLE"

            # Check if PR has merge conflicts with error handling
            if [ "$PR_MERGEABLE" = "CONFLICTING" ]; then
              echo "âš ï¸ PR #$PR_NUMBER has conflicts, needs manual intervention"

              # Add a comment to notify about conflicts (with retry)
              COMMENT_SUCCESS=false
              for comment_attempt in 1 2; do
                if gh pr comment "$PR_NUMBER" --body "ðŸš¨ Merge Conflicts Detected - This release PR has merge conflicts that need to be resolved manually." 2>/dev/null; then
                  echo "ðŸ’¬ Added conflict notification comment to PR #$PR_NUMBER"
                  COMMENT_SUCCESS=true
                  break
                else
                  echo "âš ï¸ Failed to add comment (attempt $comment_attempt)"
                  sleep 2
                fi
              done
              
              if [ "$COMMENT_SUCCESS" = "false" ]; then
                echo "âŒ Could not add comment to PR #$PR_NUMBER, but continuing..."
              fi

            elif [ "$PR_MERGEABLE" = "UNKNOWN" ]; then
              echo "â“ PR #$PR_NUMBER merge status is unknown, will check again later"

            else
              echo "âœ… PR #$PR_NUMBER is ready to merge (no conflicts)"
            fi

            # Check if PR is stale (older than 7 days) with error handling
            echo "ðŸ•’ Checking staleness of PR #$PR_NUMBER..."
            if PR_CREATED=$(gh pr view "$PR_NUMBER" --json createdAt --jq '.createdAt' 2>/dev/null); then
              if PR_CREATED_TIMESTAMP=$(date -d "$PR_CREATED" +%s 2>/dev/null); then
                CURRENT_TIMESTAMP=$(date +%s)
                DAYS_OLD=$(( (CURRENT_TIMESTAMP - PR_CREATED_TIMESTAMP) / 86400 ))

                if [ "$DAYS_OLD" -gt 7 ]; then
                  echo "â° PR #$PR_NUMBER is $DAYS_OLD days old, adding stale notification"

                  # Add stale comment with retry
                  STALE_COMMENT_SUCCESS=false
                  for stale_attempt in 1 2; do
                    if gh pr comment "$PR_NUMBER" --body "ðŸ“… Stale Release PR - This release PR has been open for $DAYS_OLD days. Consider merging, closing, or waiting for more changes." 2>/dev/null; then
                      echo "ðŸ’¬ Added stale notification to PR #$PR_NUMBER"
                      STALE_COMMENT_SUCCESS=true
                      break
                    else
                      echo "âš ï¸ Failed to add stale comment (attempt $stale_attempt)"
                      sleep 2
                    fi
                  done
                  
                  if [ "$STALE_COMMENT_SUCCESS" = "false" ]; then
                    echo "âŒ Could not add stale comment to PR #$PR_NUMBER, but continuing..."
                  fi
                else
                  echo "âœ… PR #$PR_NUMBER is recent ($DAYS_OLD days old)"
                fi
              else
                echo "âš ï¸ Could not parse creation date for PR #$PR_NUMBER"
              fi
            else
              echo "âš ï¸ Could not retrieve creation date for PR #$PR_NUMBER"
            fi

            echo "âœ… Finished processing PR #$PR_NUMBER"
          done

      - name: Trigger release-please if no open PRs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ” Checking if release-please should be triggered..."

          # Check if there are any commits since last release that would warrant a new release
          LAST_RELEASE=$(gh release list --limit 1 --json tagName --jq '.[0].tagName // empty')

          if [ -z "$LAST_RELEASE" ]; then
            echo "â„¹ï¸ No previous releases found"
            exit 0
          fi

          # Fetch tags with retry mechanism and comprehensive error handling
          echo "ðŸ”„ Fetching tags and ensuring repository state..."
          for attempt in 1 2 3; do
            if git fetch --tags --prune 2>/dev/null; then
              echo "âœ… Successfully fetched tags (attempt $attempt)"
              break
            else
              echo "âš ï¸ Failed to fetch tags (attempt $attempt)"
              if [ $attempt -eq 3 ]; then
                echo "âŒ All fetch attempts failed, using local repository state"
              else
                sleep $((attempt * 2))
              fi
            fi
          done

          # Verify tag exists locally before attempting comparison
          if ! git tag -l | grep -q "^${LAST_RELEASE}$" 2>/dev/null; then
            echo "âš ï¸ Release tag '$LAST_RELEASE' not found locally, skipping commit comparison"
            echo "ðŸ“Š Cannot count commits since last release (tag unavailable)"
            COMMITS_SINCE_RELEASE="unknown"
          else
            # Check for commits since last release with enhanced error handling
            COMMITS_SINCE_RELEASE=$(git rev-list --count "${LAST_RELEASE}..HEAD" 2>/dev/null || echo "0")
            echo "ðŸ“Š Found $COMMITS_SINCE_RELEASE commits since last release ($LAST_RELEASE)"
          fi

          # Check if there's an open release PR with retry mechanism
          echo "ðŸ” Checking for open release PRs..."
          OPEN_RELEASE_PRS=""
          for attempt in 1 2 3; do
            if OPEN_RELEASE_PRS=$(gh pr list --label "autorelease: pending" --json number --jq '. | length' 2>/dev/null); then
              echo "âœ… Successfully retrieved PR count: $OPEN_RELEASE_PRS (attempt $attempt)"
              break
            else
              echo "âš ï¸ Failed to retrieve PR list (attempt $attempt)"
              if [ $attempt -eq 3 ]; then
                echo "âŒ All PR retrieval attempts failed, assuming 0 PRs"
                OPEN_RELEASE_PRS="0"
              else
                sleep $((attempt * 2))
              fi
            fi
          done

          # Enhanced logic with resilient handling of unknown commit counts
          if [ "$COMMITS_SINCE_RELEASE" = "unknown" ]; then
            echo "âš ï¸ Cannot determine commit count, skipping automated decisions"
            echo "â„¹ï¸ Manual verification may be needed"
          elif [ "$OPEN_RELEASE_PRS" -eq 0 ] && [ "$COMMITS_SINCE_RELEASE" -gt 0 ]; then
            echo "ðŸš€ No open release PR found, but there are $COMMITS_SINCE_RELEASE new commits"
            echo "Release-please should create a new PR on the next qualifying commit"
          elif [ "$OPEN_RELEASE_PRS" -gt 0 ]; then
            echo "âœ… Found $OPEN_RELEASE_PRS open release PR(s)"
          else
            echo "â„¹ï¸ No new commits since last release"
          fi

      - name: Summary
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "## ðŸ“Š Release Please Maintenance Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Count release PRs
          RELEASE_COUNT=$(gh pr list --label "autorelease: pending" --json number --jq '. | length' 2>/dev/null || echo "0")
          echo "**Release PRs:** $RELEASE_COUNT open" >> $GITHUB_STEP_SUMMARY

          # Get last release info
          LAST_RELEASE=$(gh release list --limit 1 --json tagName,publishedAt --jq '.[0] // empty' 2>/dev/null)
          if [ -n "$LAST_RELEASE" ]; then
            RELEASE_TAG=$(echo "$LAST_RELEASE" | jq -r '.tagName')
            RELEASE_DATE=$(echo "$LAST_RELEASE" | jq -r '.publishedAt' | cut -d'T' -f1)
            echo "**Last Release:** $RELEASE_TAG ($RELEASE_DATE)" >> $GITHUB_STEP_SUMMARY
          fi

          # Count commits since last release with comprehensive error handling
          if [ -n "$LAST_RELEASE" ]; then
            RELEASE_TAG=$(echo "$LAST_RELEASE" | jq -r '.tagName')
            
            # Ensure tags are fetched with retry logic
            echo "ðŸ”„ Ensuring tags are available for summary..."
            FETCH_SUCCESS=false
            for attempt in 1 2 3; do
              if git fetch --tags --prune 2>/dev/null; then
                FETCH_SUCCESS=true
                break
              else
                echo "âš ï¸ Tag fetch attempt $attempt failed"
                sleep $((attempt))
              fi
            done
            
            if [ "$FETCH_SUCCESS" = "true" ] && git tag -l | grep -q "^${RELEASE_TAG}$" 2>/dev/null; then
              COMMITS_COUNT=$(git rev-list --count "${RELEASE_TAG}..HEAD" 2>/dev/null || echo "unknown")
              echo "**New Commits:** $COMMITS_COUNT since last release" >> $GITHUB_STEP_SUMMARY
            else
              echo "**New Commits:** Unable to determine (tag fetch failed)" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "**New Commits:** No previous release found" >> $GITHUB_STEP_SUMMARY
          fi
