---
name: Auto Rebase

on:
  push:
    branches:
      - main
  schedule:
    # Run daily at 9 AM UTC to keep all Dependabot PRs current
    - cron: '0 9 * * *'
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to rebase (optional)'
        required: false
        type: string

concurrency:
  group: auto-rebase-${{ github.ref }}
  cancel-in-progress: true

jobs:
  auto-rebase:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.PRIVATE_KEY }}

      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Setup GitHub CLI and Git Config
        run: |
          gh auth setup-git

          # Configure git identity and settings for commits
          git config --global user.name "resume-pipeline-bot[bot]"
          git config --global user.email "noreply@github.com"
          git config --global init.defaultBranch main

          # Suppress git hints to reduce warnings
          git config --global advice.defaultBranchName false
          git config --global advice.detachedHead false
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Resilient Dependabot Management with Circuit Breaker
        if: github.event_name == 'push' || github.event_name == 'schedule' || !github.event.inputs.pr_number
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          echo "üõ°Ô∏è Resilient Dependabot PR management with exponential backoff and circuit breaker..."

          # Circuit breaker and retry configuration
          MAX_ATTEMPTS=5
          BASE_DELAY=3
          CIRCUIT_BREAKER_THRESHOLD=3
          CONSECUTIVE_FAILURES=0
          TOTAL_PROCESSED=0
          SUCCESSFUL_OPERATIONS=0

          # GitHub API health check with retry
          echo "üîç Checking GitHub API health..."
          API_HEALTHY=false
          for health_attempt in 1 2 3; do
            if timeout 10 gh api /rate_limit >/dev/null 2>&1; then
              API_HEALTHY=true
              echo "‚úÖ GitHub API responding normally"
              break
            else
              echo "‚ö†Ô∏è GitHub API health check failed (attempt $health_attempt/3)"
              if [ $health_attempt -lt 3 ]; then
                sleep $((health_attempt * 2))
              fi
            fi
          done

          if [ "$API_HEALTHY" = "false" ]; then
            echo "üö® GitHub API appears unhealthy, implementing extended delays and reduced batch sizes"
            MAX_ATTEMPTS=3
            BASE_DELAY=10
          fi

          # Resilient PR list retrieval with exponential backoff
          echo "üîç Retrieving Dependabot PRs with resilient retry logic..."
          DEPENDABOT_PRS=""

          for attempt in $(seq 1 $MAX_ATTEMPTS); do
            echo "üì° Fetching PR list (attempt $attempt/$MAX_ATTEMPTS)..."

            # Calculate exponential backoff delay
            if [ $attempt -gt 1 ]; then
              DELAY=$((BASE_DELAY * (1 << (attempt - 2))))
              if [ $DELAY -gt 60 ]; then DELAY=60; fi
              echo "‚è±Ô∏è Waiting ${DELAY} seconds (exponential backoff)..."
              sleep $DELAY
            fi

            # Circuit breaker check
            if [ $CONSECUTIVE_FAILURES -ge $CIRCUIT_BREAKER_THRESHOLD ]; then
              echo "üîå Circuit breaker activated - cooling period (30s)..."
              sleep 30
              CONSECUTIVE_FAILURES=0
            fi

            # Attempt to fetch PRs with timeout
            if timeout 30 gh pr list --author "dependabot[bot]" --json number,title,mergeable,headRefName,createdAt,commits --jq '.[] | @json' > /tmp/pr_list.txt 2>/dev/null; then
              DEPENDABOT_PRS=$(cat /tmp/pr_list.txt)
              echo "‚úÖ Successfully retrieved Dependabot PRs on attempt $attempt"
              CONSECUTIVE_FAILURES=0
              break
            else
              echo "‚ùå Failed to retrieve PR list (attempt $attempt)"
              CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))

              if [ $attempt -eq $MAX_ATTEMPTS ]; then
                echo "üö® All attempts to retrieve PR list failed - enabling graceful degradation"
                echo "::warning::Auto-rebase could not retrieve PR list after $MAX_ATTEMPTS attempts"
              fi
            fi
          done

          if [ -z "$DEPENDABOT_PRS" ]; then
            echo "‚ÑπÔ∏è No Dependabot PRs found or retrieval failed"
          else
            RECREATED_COUNT=0
            CLOSED_COUNT=0

            # Process each PR with individual resilience
            echo "$DEPENDABOT_PRS" | while IFS= read -r pr_json; do
              PR_DATA=$(echo "$pr_json" | jq -r '.')
              PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')
              PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
              PR_MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable')
              PR_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
              PR_CREATED=$(echo "$PR_DATA" | jq -r '.createdAt')

              echo ""
              echo "üì¶ Dependabot PR #$PR_NUMBER: $PR_TITLE"
              echo "   Branch: $PR_BRANCH"
              echo "   Status: $PR_MERGEABLE"
              echo "   Created: $PR_CREATED"

              # Check if PR has invalid conventional commit format
              INVALID_COMMIT_FORMAT=false
              LATEST_COMMIT_MSG=$(echo "$PR_DATA" | jq -r '.commits[-1].messageHeadline // empty')

              # Note: Dependabot uses proper conventional commit format: chore(deps):, chore(deps-dev):, ci:
              # Only flag truly invalid patterns, not proper Dependabot commits
              if [[ "$LATEST_COMMIT_MSG" =~ ^[a-z]+$ ]] || [[ "$LATEST_COMMIT_MSG" =~ ^[A-Z] ]] || [[ ! "$LATEST_COMMIT_MSG" =~ ^[a-z]+(\([a-z-]+\))?:\ .+ ]]; then
                echo "‚ùå PR #$PR_NUMBER has INVALID conventional commit format: $LATEST_COMMIT_MSG"
                INVALID_COMMIT_FORMAT=true
              fi

              # Calculate PR age in days
              if command -v date >/dev/null 2>&1; then
                if [[ "$OSTYPE" == "darwin"* ]]; then
                  # macOS date command
                  PR_AGE_DAYS=$(( ( $(date +%s) - $(date -j -f "%Y-%m-%dT%H:%M:%SZ" "${PR_CREATED}" +%s) ) / 86400 ))
                else
                  # Linux date command
                  PR_AGE_DAYS=$(( ( $(date +%s) - $(date -d "${PR_CREATED}" +%s) ) / 86400 ))
                fi
              else
                PR_AGE_DAYS=0
              fi

              echo "   Age: ${PR_AGE_DAYS} days"

              # AGGRESSIVE STRATEGY: Force close and recreate PRs that are:
              # 1. CONFLICTING
              # 2. UNKNOWN status
              # 3. Have invalid conventional commit format
              # 4. Are older than 7 days
              SHOULD_FORCE_RECREATE=false
              REASON=""

              if [ "$PR_MERGEABLE" = "CONFLICTING" ]; then
                SHOULD_FORCE_RECREATE=true
                REASON="has merge conflicts"
              elif [ "$PR_MERGEABLE" = "UNKNOWN" ]; then
                SHOULD_FORCE_RECREATE=true
                REASON="has unknown merge status"
              elif [ "$INVALID_COMMIT_FORMAT" = true ]; then
                SHOULD_FORCE_RECREATE=true
                REASON="has invalid conventional commit format"
              elif [ "$PR_AGE_DAYS" -gt 21 ]; then
                SHOULD_FORCE_RECREATE=true
                REASON="is older than 21 days (${PR_AGE_DAYS} days)"
              fi

              if [ "$SHOULD_FORCE_RECREATE" = true ]; then
                echo "üî• FORCE RECREATING PR #$PR_NUMBER because it $REASON"

                # Resilient PR closure with retry logic
                CLOSE_SUCCESS=false
                for close_attempt in 1 2 3; do
                  echo "   üîÑ Closing PR #$PR_NUMBER (attempt $close_attempt/3)..."

                  if timeout 15 gh pr close "$PR_NUMBER" --comment "ü§ñ Auto-closing this PR because it $REASON. Dependabot will automatically recreate it with the latest changes and correct format." 2>/dev/null; then
                    echo "   ‚úÖ Successfully closed PR #$PR_NUMBER on attempt $close_attempt"
                    CLOSE_SUCCESS=true
                    SUCCESSFUL_OPERATIONS=$((SUCCESSFUL_OPERATIONS + 1))
                    break
                  else
                    echo "   ‚ùå Failed to close PR #$PR_NUMBER (attempt $close_attempt)"
                    if [ $close_attempt -lt 3 ]; then
                      echo "   üîÑ Retrying in $((close_attempt * 3)) seconds..."
                      sleep $((close_attempt * 3))
                    fi
                  fi
                done

                if [ "$CLOSE_SUCCESS" = "true" ]; then
                  echo "   2. Waiting 5 seconds for Dependabot to detect closure..."
                  sleep 5
                  echo "‚úÖ PR #$PR_NUMBER closed - Dependabot will recreate automatically"
                  CLOSED_COUNT=$((CLOSED_COUNT + 1))
                else
                  echo "   ‚ö†Ô∏è Failed to close PR #$PR_NUMBER after 3 attempts - will try next run"
                  echo "::warning::Failed to close PR #$PR_NUMBER during auto-rebase"
                fi
              else
                echo "‚úÖ PR #$PR_NUMBER is current and valid (${PR_AGE_DAYS} days old)"
                SUCCESSFUL_OPERATIONS=$((SUCCESSFUL_OPERATIONS + 1))
              fi

              TOTAL_PROCESSED=$((TOTAL_PROCESSED + 1))

              # Rate limiting protection - pause between PR operations
              if [ $((TOTAL_PROCESSED % 3)) -eq 0 ]; then
                echo "üîÑ Rate limiting pause (2s) after processing $TOTAL_PROCESSED PRs..."
                sleep 2
              fi
            done

            echo ""
            echo "üìä Resilient Management Results:"
            echo "   üìà Total PRs processed: $TOTAL_PROCESSED"
            echo "   ‚úÖ Successful operations: $SUCCESSFUL_OPERATIONS"
            echo "   üî• PRs force-closed for recreation: $CLOSED_COUNT"
            echo "   üìù Success rate: $((SUCCESSFUL_OPERATIONS * 100 / (TOTAL_PROCESSED > 0 ? TOTAL_PROCESSED : 1)))%"
            echo "   üõ°Ô∏è Circuit breaker activations: $((CONSECUTIVE_FAILURES >= CIRCUIT_BREAKER_THRESHOLD ? 1 : 0))"
            echo "   üåê GitHub API status: $([ "$API_HEALTHY" = "true" ] && echo "Healthy ‚úÖ" || echo "Degraded ‚ö†Ô∏è")"
            echo ""
            echo "üîß Management Strategy Applied:"
            echo "   ‚Ä¢ CONFLICTING PRs: Force-closed for automatic recreation"
            echo "   ‚Ä¢ UNKNOWN status PRs: Force-closed for automatic recreation"
            echo "   ‚Ä¢ Invalid commit format: Force-closed for recreation with correct format"
            echo "   ‚Ä¢ Stale PRs (>21 days): Force-closed for recreation with latest dependencies"
            echo "   ‚Ä¢ Valid PRs: Left unchanged"
            echo ""
            echo "‚ö° Next execution: Daily at 9 AM UTC or on every push to main"
            echo "üõ°Ô∏è Resilience: Exponential backoff, circuit breaker, and graceful degradation enabled"

            # Cleanup temporary files
            rm -f /tmp/pr_list.txt
          fi

      - name: Resilient Specific PR Rebase
        if: github.event.inputs.pr_number
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          PR_NUMBER="${{ github.event.inputs.pr_number }}"
          echo "üõ°Ô∏è Resilient handling of specific PR #$PR_NUMBER"

          # Resilient PR information retrieval
          PR_AUTHOR=""
          for attempt in 1 2 3; do
            echo "üîç Retrieving PR #$PR_NUMBER information (attempt $attempt/3)..."

            if PR_AUTHOR=$(timeout 15 gh pr view "$PR_NUMBER" --json author --jq '.author.login' 2>/dev/null); then
              echo "‚úÖ Successfully retrieved PR author: $PR_AUTHOR"
              break
            else
              echo "‚ö†Ô∏è Failed to retrieve PR information (attempt $attempt)"
              if [ $attempt -lt 3 ]; then
                sleep $((attempt * 2))
              else
                echo "üö® Could not retrieve PR #$PR_NUMBER information after 3 attempts"
                echo "::error::Unable to process PR #$PR_NUMBER - API may be temporarily unavailable"
                exit 1
              fi
            fi
          done

          if [ "$PR_AUTHOR" = "dependabot[bot]" ]; then
            echo "üì¶ This is a Dependabot PR - applying resilient recreation strategy..."

            # Resilient PR details retrieval
            PR_DATA=""
            for data_attempt in 1 2 3; do
              echo "üìã Retrieving PR details (attempt $data_attempt/3)..."

              if PR_DATA=$(timeout 20 gh pr view "$PR_NUMBER" --json title,mergeable,commits,createdAt 2>/dev/null); then
                echo "‚úÖ Successfully retrieved PR details"
                break
              else
                echo "‚ö†Ô∏è Failed to retrieve PR details (attempt $data_attempt)"
                if [ $data_attempt -lt 3 ]; then
                  sleep $((data_attempt * 3))
                else
                  echo "üö® Could not retrieve PR details after 3 attempts"
                  echo "::warning::Unable to analyze PR #$PR_NUMBER details - skipping recreation check"
                  exit 0
                fi
              fi
            done

            PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
            PR_MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable')
            LATEST_COMMIT_MSG=$(echo "$PR_DATA" | jq -r '.commits[-1].messageHeadline // empty')

            echo "   üìÑ Title: $PR_TITLE"
            echo "   üìä Status: $PR_MERGEABLE"
            echo "   üí¨ Latest commit: $LATEST_COMMIT_MSG"

            # Check for invalid format
            INVALID_FORMAT=false
            # Note: Dependabot uses proper conventional commit format: chore(deps):, chore(deps-dev):, ci:
            # Only flag truly invalid patterns, not proper Dependabot commits
            if [[ "$LATEST_COMMIT_MSG" =~ ^[a-z]+$ ]] || [[ "$LATEST_COMMIT_MSG" =~ ^[A-Z] ]] || [[ ! "$LATEST_COMMIT_MSG" =~ ^[a-z]+(\([a-z-]+\))?:\ .+ ]]; then
              INVALID_FORMAT=true
            fi

            if [ "$PR_MERGEABLE" = "CONFLICTING" ] || [ "$PR_MERGEABLE" = "UNKNOWN" ] || [ "$INVALID_FORMAT" = true ]; then
              echo "üî• Force closing PR #$PR_NUMBER for recreation..."

              # Resilient PR closure
              CLOSE_SUCCESS=false
              for close_attempt in 1 2 3; do
                echo "üîÑ Closing PR #$PR_NUMBER (attempt $close_attempt/3)..."

                if timeout 15 gh pr close "$PR_NUMBER" --comment "ü§ñ Manual trigger: Force-closing this PR for recreation with latest format and no conflicts." 2>/dev/null; then
                  echo "‚úÖ Successfully closed PR #$PR_NUMBER on attempt $close_attempt"
                  CLOSE_SUCCESS=true
                  break
                else
                  echo "‚ùå Failed to close PR #$PR_NUMBER (attempt $close_attempt)"
                  if [ $close_attempt -lt 3 ]; then
                    sleep $((close_attempt * 2))
                  fi
                fi
              done

              if [ "$CLOSE_SUCCESS" = "true" ]; then
                echo "‚úÖ PR #$PR_NUMBER closed - Dependabot will recreate automatically"
              else
                echo "‚ö†Ô∏è Failed to close PR #$PR_NUMBER after 3 attempts"
                echo "::warning::Manual intervention may be required for PR #$PR_NUMBER"
              fi
            else
              echo "‚úÖ PR #$PR_NUMBER looks good, no action needed"
            fi
          else
            # For other PRs, attempt resilient direct rebase
            echo "üë§ Non-Dependabot PR - attempting resilient direct rebase..."

            # Resilient branch name retrieval
            PR_BRANCH=""
            for branch_attempt in 1 2 3; do
              echo "üåø Retrieving branch name (attempt $branch_attempt/3)..."

              if PR_BRANCH=$(timeout 10 gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName' 2>/dev/null); then
                echo "‚úÖ Successfully retrieved branch: $PR_BRANCH"
                break
              else
                echo "‚ö†Ô∏è Failed to retrieve branch name (attempt $branch_attempt)"
                if [ $branch_attempt -lt 3 ]; then
                  sleep $((branch_attempt * 2))
                else
                  echo "üö® Could not retrieve branch name after 3 attempts"
                  echo "::error::Unable to determine branch for PR #$PR_NUMBER"
                  exit 1
                fi
              fi
            done

            # Resilient git operations with comprehensive error handling
            echo "üîÑ Performing resilient git rebase operations..."

            # Fetch with retry
            FETCH_SUCCESS=false
            for fetch_attempt in 1 2 3; do
              echo "üì• Fetching branch $PR_BRANCH (attempt $fetch_attempt/3)..."

              if timeout 30 git fetch origin "$PR_BRANCH" 2>/dev/null; then
                echo "‚úÖ Successfully fetched $PR_BRANCH"
                FETCH_SUCCESS=true
                break
              else
                echo "‚ùå Failed to fetch $PR_BRANCH (attempt $fetch_attempt)"
                if [ $fetch_attempt -lt 3 ]; then
                  sleep $((fetch_attempt * 3))
                fi
              fi
            done

            if [ "$FETCH_SUCCESS" = "false" ]; then
              echo "üö® Failed to fetch branch after 3 attempts"
              echo "::error::Unable to fetch branch $PR_BRANCH for PR #$PR_NUMBER"
              exit 1
            fi

            # Checkout with error handling
            if git checkout "$PR_BRANCH" 2>/dev/null; then
              echo "‚úÖ Successfully checked out $PR_BRANCH"
            else
              echo "‚ùå Failed to checkout $PR_BRANCH"
              echo "::error::Unable to checkout branch for PR #$PR_NUMBER"
              exit 1
            fi

            # Rebase with enhanced error handling
            echo "üîÑ Attempting rebase onto main..."
            if timeout 120 git rebase origin/main 2>/dev/null; then
              echo "‚úÖ Rebase successful, pushing changes..."

              # Push with retry logic
              PUSH_SUCCESS=false
              for push_attempt in 1 2 3; do
                echo "üì§ Pushing rebased branch (attempt $push_attempt/3)..."

                if timeout 30 git push --force-with-lease origin "$PR_BRANCH" 2>/dev/null; then
                  echo "‚úÖ Successfully pushed rebased changes"
                  PUSH_SUCCESS=true
                  break
                else
                  echo "‚ùå Failed to push changes (attempt $push_attempt)"
                  if [ $push_attempt -lt 3 ]; then
                    sleep $((push_attempt * 2))
                  fi
                fi
              done

              if [ "$PUSH_SUCCESS" = "true" ]; then
                echo "‚úÖ Successfully rebased PR #$PR_NUMBER"
              else
                echo "‚ö†Ô∏è Rebase succeeded but failed to push after 3 attempts"
                echo "::warning::PR #$PR_NUMBER was rebased but changes could not be pushed"
                exit 1
              fi
            else
              echo "‚ùå Failed to rebase PR #$PR_NUMBER due to conflicts or timeout"
              echo "üîÑ Aborting rebase to clean state..."
              git rebase --abort 2>/dev/null || true
              echo "::error::Rebase failed for PR #$PR_NUMBER - manual intervention required"
              exit 1
            fi
          fi

      - name: Resilience Summary
        if: always()
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          echo "## üõ°Ô∏è Resilient Auto-Rebase Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event_name }}" = "push" ]; then
            echo "**Trigger**: Push to main branch" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ github.event_name }}" = "schedule" ]; then
            echo "**Trigger**: Scheduled daily execution (9 AM UTC)" >> $GITHUB_STEP_SUMMARY
          elif [ -n "${{ github.event.inputs.pr_number }}" ]; then
            echo "**Trigger**: Manual execution for PR #${{ github.event.inputs.pr_number }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Trigger**: Manual execution for all PRs" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üõ°Ô∏è Resilient Management Strategy" >> $GITHUB_STEP_SUMMARY
          echo "- **Exponential Backoff**: 3-60s delays with circuit breaker protection" >> $GITHUB_STEP_SUMMARY
          echo "- **Circuit Breaker**: Activates after 3 consecutive failures (30s cooling)" >> $GITHUB_STEP_SUMMARY
          echo "- **API Health Checks**: Pre-operation GitHub API validation" >> $GITHUB_STEP_SUMMARY
          echo "- **Timeout Protection**: All operations time-bounded (10-120s)" >> $GITHUB_STEP_SUMMARY
          echo "- **Graceful Degradation**: Continues with reduced functionality on failures" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ü§ñ Dependabot Management Strategy" >> $GITHUB_STEP_SUMMARY
          echo "- **CONFLICTING PRs**: Force-closed for automatic recreation" >> $GITHUB_STEP_SUMMARY
          echo "- **UNKNOWN status PRs**: Force-closed for automatic recreation" >> $GITHUB_STEP_SUMMARY
          echo "- **Invalid commit format**: Force-closed for recreation with correct format" >> $GITHUB_STEP_SUMMARY
          echo "- **Stale PRs (>21 days)**: Force-closed for recreation with latest dependencies" >> $GITHUB_STEP_SUMMARY
          echo "- **Valid PRs**: Left unchanged" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Resilient dependabot count with fallback
          DEPENDABOT_COUNT=$(timeout 10 gh pr list --author "dependabot[bot]" --json number --jq '. | length' 2>/dev/null || echo "Unknown")
          echo "**Current Dependabot PRs**: $DEPENDABOT_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üîÑ **Next execution**: Daily at 9 AM UTC or on push to main" >> $GITHUB_STEP_SUMMARY
          echo "üõ°Ô∏è **Resilience Features**: Exponential backoff, circuit breaker, API health monitoring" >> $GITHUB_STEP_SUMMARY
